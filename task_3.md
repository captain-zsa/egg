# Задача №3

__Исходный код:__
```js
let list = readHugeList();
let nextListItem = function () {
  let item = list.pop();
  if (item) {
    // ... обработка записи
    nextListItem();
  }
};
```

## В чем проблема, если список будет слишком длинным?

Проблема в стэке. Функция nextListItem() может вызываться определенное количество раз. В хроме, к примеру, таких вызовов будет 13902 (если просто вызывать рекурсивно функцию без доп. переменных), в сафари – 45613. Далее стек переполняется и выдается ошибка `RangeError: Maximum call stack size exceeded.`. В данном примере конечно вопрос преобразований и стэк вероятнее всего забьется сильно быстрее (если напилят ещё let или const всяких с разными значениями).

## Решение проблемы

Самое простое – добавить `setTimeout` при рекурсивном вызове.

```js
let list = readHugeList();
let nextListItem = function () {
  let item = list.pop();
  if (item) {
    // ... обработка записи
    setTimeout(nextListItem(), 0);
  }
};
```

Почему setTimeout сработает – можно сказать, "чистит" стэк (ну да, не она чистит, ну вы поняли))

Честно говоря, больше и чаще работал с DOM, а там такие манипуляции могут плохо кончиться, так как грузиться будет всё достаточно долго. Если с DOM работаем в этом всём – лучше 100 раз подумать, надо ли вообще обрабатывать такие большие массивы, или делать это "порционно".

["К оглавлению"](README.md)

["< Так, стоп, а чо там в предыдущей"](task_2.md)

["Уперёд к следующей таске! >"](task_4.md)
