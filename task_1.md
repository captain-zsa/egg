# Задача №1

__Исходный код:__
```js
for (var i = 0; i <5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}
```

## Объяснение

### Что хотелось сделать?

Разработчик хотел вывести последовательно `0`, `1`, `2`, `3`, `4` каждое значение через `+1 секунду`. Такая проблема возникает не только при работе с `setTimeout()`, но и при работе с "асинхронщиной".

### Почему возникает проблема?

`setTimeout()` создаёт функцию, у которой есть доступ к внешней области видимости. Внешняя область видимости работает так: на каждой итерации цикла значение `i` действительно увеличивается, но так как `setTimeout` отрабатывает уже после работы цикла – будет выводиться только последнее значение, которое попало на проверку в цикле. Но почему `5` – потому что последняя проверка условия `i < 5` проходит тогда, когда значение `i++` увеличивается ровно до `5`. Именно из-за этого получается, что последнее значение будет `5`, а не `4`, хотя равенство строгое. Это легко понять из такого примера:

```js
for (var i = 0; i < 5; i++) {
  console.log(i); // последовательно выведет 0,1,2,3,4 и остановится
}

console.log(i); // выведет 5, так как последнее значение из цикла, которое сверялось, было как раз 5.
```

### Что делать, чтобы всё работало как надо (как задумывал разработчик)?

Самый банальный вариант – использовать `let i = 0` в цикле (hello, ES6). Но давайте не останавливаться на банальщине и окунёмся в мир легаси))

```js
for (var i = 0; i < 5; i++) {
  setTimeout(function(iInFunction) {
    console.log(iInFunction);
  }(i), i * 1000);
}
```

Этот код отработает также верно, как и с `let i = 0;`. Почему? Потому что мы используем область видимости фукнции, передавая в неё параметр нужный нам.

Я думаю, объяснения хватит))

P.S. А можно сделать атата за то, что `var` прямо в цикле используется?)) Я за `vars-on-top`. JS и так перемещает вверх все объявления переменных, а нам разработчикам ещё лучше будет видеть, что вот мы сейчас будем работать с этим, вот тем, а ещё вот тем и проще будет дорабатывать/дебажить код.
